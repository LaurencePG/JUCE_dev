/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

AudioProcessor* JUCE_CALLTYPE createPluginFilter();

const float defaultGain = 1.0f;

//==============================================================================
VolumeKnobAudioProcessor::VolumeKnobAudioProcessor(){
    // Set up some default values..
    gain = defaultGain;

    lastUIWidth = 400;
    lastUIHeight = 200;
}

//==============================================================================
VolumeKnobAudioProcessor::~VolumeKnobAudioProcessor(){ }
void VolumeKnobAudioProcessor::processBlock(AudioSampleBuffer& buffer, MidiBuffer& midiMessages){
    const int numSamples = buffer.getNumSamples();
    int channel = 0;
    
    /*
     // Go through the incoming data, and apply our gain to it...
     for(channel = 0; channel < getNumInputChannels(); ++channel){
     buffer.applyGain(channel, 0, buffer.getNumSamples(), gain);
     }*/
    
    for(channel = 0; channel < getNumInputChannels(); ++channel){
        float* channelData = buffer.getWritePointer(channel);
        
        for(int i = 0; i < numSamples; ++i){
            const float in = channelData[i];
            channelData[i] = (in * gain);
        }
    }
    
    // In case we have more outputs than inputs, we'll clear any output
    // channels that didn't contain input data,(because these aren't
    // guaranteed to be empty - they may contain garbage).
    for(int i = getNumInputChannels(); i < getNumOutputChannels(); ++i){
        buffer.clear(i, 0, buffer.getNumSamples());
    }
}
//==============================================================================
int VolumeKnobAudioProcessor::getNumParameters(){
    return totalNumParams;
}

float VolumeKnobAudioProcessor::getParameter(int index){
    // This method will be called by the host, probably on the audio thread, so
    // it's absolutely time-critical. Don't use critical sections or anything
    // UI-related, or anything at all that may block in any way!
    switch(index){
        case gainParam:     return gain;
        default:            return 0.0f;
    }
}

void VolumeKnobAudioProcessor::setParameter(int index, float newValue){
    // This method will be called by the host, probably on the audio thread, so
    // it's absolutely time-critical. Don't use critical sections or anything
    // UI-related, or anything at all that may block in any way!
    switch(index){
        case gainParam:     gain = newValue;  break;
        default:            break;
    }
}

float VolumeKnobAudioProcessor::getParameterDefaultValue(int index){
    switch(index){
        case gainParam:     return defaultGain;
        default:            break;
    }
    return 0.0f;
}

const String VolumeKnobAudioProcessor::getParameterName(int index){
    switch(index){
        case gainParam:     return "gain";
        default:            break;
    }
    return String::empty;
}

const String VolumeKnobAudioProcessor::getParameterText(int index){
    return String(getParameter(index), 2);
}

//==============================================================================
void VolumeKnobAudioProcessor::prepareToPlay(double sampleRate, int /*samplesPerBlock*/){
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void VolumeKnobAudioProcessor::releaseResources(){
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void VolumeKnobAudioProcessor::reset(){
    // Use this method as the place to clear any delay lines, buffers, etc, as it
    // means there's been a break in the audio's continuity.
}

//==============================================================================
AudioProcessorEditor* VolumeKnobAudioProcessor::createEditor(){
    return new VolumeKnobAudioProcessorEditor(*this);
}

//==============================================================================
void VolumeKnobAudioProcessor::getStateInformation(MemoryBlock& destData){
    // You should use this method to store your parameters in the memory block.
    // Here's an example of how you can use XML to make it easy and more robust:

    // Create an outer XML element..
    XmlElement xml("MYPLUGINSETTINGS");

    // add some attributes to it..
    xml.setAttribute("uiWidth", lastUIWidth);
    xml.setAttribute("uiHeight", lastUIHeight);
    xml.setAttribute("gain", gain);

    // then use this helper function to stuff it into the binary blob and return it..
    copyXmlToBinary(xml, destData);
}

void VolumeKnobAudioProcessor::setStateInformation(const void* data, int sizeInBytes){
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.

    // This getXmlFromBinary() helper function retrieves our XML from the binary blob..
    ScopedPointer<XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));

    if(xmlState != nullptr){
        // make sure that it's actually our type of XML object..
        if(xmlState->hasTagName("MYPLUGINSETTINGS")){
            // ok, now pull out our parameters..
            lastUIWidth  = xmlState->getIntAttribute("uiWidth", lastUIWidth);
            lastUIHeight = xmlState->getIntAttribute("uiHeight", lastUIHeight);

            gain  =(float) xmlState->getDoubleAttribute("gain", gain);
        }
    }
}

const String VolumeKnobAudioProcessor::getInputChannelName(const int channelIndex) const{
    return String(channelIndex + 1);
}

const String VolumeKnobAudioProcessor::getOutputChannelName(const int channelIndex) const{
    return String(channelIndex + 1);
}

bool VolumeKnobAudioProcessor::isInputChannelStereoPair(int /*index*/) const{
    return true;
}

bool VolumeKnobAudioProcessor::isOutputChannelStereoPair(int /*index*/) const{
    return true;
}

bool VolumeKnobAudioProcessor::acceptsMidi() const{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool VolumeKnobAudioProcessor::producesMidi() const{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool VolumeKnobAudioProcessor::silenceInProducesSilenceOut() const{
    return false;
}

double VolumeKnobAudioProcessor::getTailLengthSeconds() const{
    return 0.0;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter(){
    return new VolumeKnobAudioProcessor();
}
